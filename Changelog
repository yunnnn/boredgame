V0.1  11/10/15: Switched to Jpanels, have basic BG/Map/Location/Unit showing.
V0.2  11/10/15: Switched to nested Panels, allowing keyboard listener and highlighting to work.
V0.3  11/15/15: Added highlighting of locations and grid movement. Flipped the location rendering so locations in
proper visual location.
V0.4  11/16/15: Added dynamic grid size and fitted unit image size. Refactored Singletons.
V0.5  11/16/15: Added new panel to represent the map BG, added simple menu

Bugs:
Resizing the screen causes the GRID to disappear (behind the MAP)
Layers apparently do nothing, it all depends on what is called first

Todos:
The unitPanel code doesn't seem to work. either it shows and isnt transparent, or doesn't show at all.
Right now I have the Game.Units coded into the Location.


Add action - response loop to move units




Old crap:


    //logging
    public void logLoad(final String imageName,
                        final int x,
                        final int y,
                        final Dimension size,
                        final Integer depth) {
        final StringBuilder sb = new StringBuilder();
        sb.append("Image: " + imageName + ", ");
        sb.append("At {" + x + "," + y + "}, ");
        sb.append("Width:" + size.getWidth() + " Height:" + size.getHeight() + " ");
        sb.append("Depth: " + depth + ". ");
        System.out.println(sb.toString());
    }

    //load an image into the layeredPane at {x,y}
    public void loadImage(final ImageIcon image,
                          final Integer depth,
                          final int x,
                          final int y) {
        final JLabel imageContainer = new JLabel(image);
        final Dimension size = imageContainer.getPreferredSize();
        imageContainer.setBounds(x, y, size.width, size.height);
        logLoad(image.getDescription(), x, y, size, depth);
        this.layeredPane.add(imageContainer, depth);
    }


public static void load() {

           //To render the image
           BufferedImage bufferedImage = new BufferedImage(800,
                   600, BufferedImage.TYPE_INT_RGB);

           //using "painter" we can draw in to "bufferedImage"
           Graphics2D painter = bufferedImage.createGraphics();

           //draw the "image" to the "bufferedImage"
           painter.drawImage(image, null, null);

        ByteBuffer imageBuffer = ByteBuffer.allocateDirect(4*source.getWidth()*source.getHeight());
        byte buffer[] = (byte[])source.getRaster().getDataElements(0,0,source.getWidth(),source.getHeight(),null);
        imageBuffer.clear();
        imageBuffer.put(buffer);
        imageBuffer.rewind();

        IntBuffer address = ByteBuffer.allocateDirect(4).order(ByteOrder.nativeOrder()).asIntBuffer();
        GL11.glGenTextures(address);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,address.get(0));

           // Setup the ST coordinate system
           GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
           GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
           glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
           glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

        GL11.glTexImage2D(GL11.GL_TEXTURE_2D,0,GL11.GL_RGBA,source.getWidth(),source.getHeight(),0,GL11.GL_RGB,GL11
                .GL_UNSIGNED_BYTE,imageBuffer);

       } catch (final FileNotFoundException e) {
           e.printStackTrace();
           System.out.println("FAILwidth=");
       } catch (IOException e) {
           System.out.println("wiFAILdth=");
           e.printStackTrace();

    }
}
    public static void load1() {
        InputStream in = null;
        try {

            in = new FileInputStream("blue.png");
            PNGDecoder decoder = new PNGDecoder(in);

            System.out.println("width =" + decoder.getWidth());
            System.out.println("height =" + decoder.getHeight());

            ByteBuffer buf = ByteBuffer.allocateDirect(4 * decoder.getWidth() * decoder.getHeight());
            decoder.decode(buf, decoder.getWidth() * 4, PNGDecoder.Format.RGB);
            buf.flip();


            int texId = GL11.glGenTextures();
            GL13.glActiveTexture(GL13.GL_TEXTURE0);
            GL11.glBindTexture(GL11.GL_TEXTURE_2D, texId);

            // Setup the ST coordinate system
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

            // Upload the texture data and generate mip maps (for scaling)
            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, decoder.getWidth(), decoder.getHeight(), 0,
                    GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, buf);





            in.close();
        } catch (final FileNotFoundException e) {
            e.printStackTrace();
            System.out.println("FAILwidth=");
        } catch (IOException e) {
            System.out.println("wiFAILdth=");
            e.printStackTrace();
        }
    }
    /**
     * Draw the sprite at the specified location
     *
     */
    public static void draw() {


        //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);


        // store the current model matrix
        glPushMatrix();


        // translate to the right location and prepare to draw
        glTranslatef(100, 200, 0);


        glEnable(GL_TEXTURE_2D);
        // draw a quad textured to match the sprite
        glBegin(GL_QUADS);
        {

            glTexCoord2f(0, 0);
            glVertex2f(0, 0);

            glTexCoord2f(0, 600);
            glVertex2f(0, 600);

            glTexCoord2f(600, 600);
            glVertex2f(600, 600);

            glTexCoord2f(600, 0);
            glVertex2f(600, 0);
        }
        glEnd();
        glDisable(GL_TEXTURE_2D);

        // restore the model view matrix to prevent contamination
        glPopMatrix();
    }



        private static void renderLoop(final LevelMap map) {
            TextureLoader.load();
            while (!Display.isCloseRequested()) {
                // Clear the screen and depth buffer
                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
                TextureLoader.draw();
               // map.render();
                Display.update();
            }
            Display.destroy();
        }


        private static void initUi() {
                try {
                    Display.setDisplayMode(new DisplayMode(SCREEN_WIDTH, SCREEN_HEIGHT));
                    Display.setTitle("Bored Game");
                    Display.setFullscreen(false);
                    Display.create();

                    glEnable(GL_TEXTURE_2D);
                    // not needed for 2d
                    glDisable(GL_DEPTH_TEST);

                    glMatrixMode(GL_PROJECTION);
                    glLoadIdentity();
                    glOrtho(0, SCREEN_WIDTH, 0, SCREEN_HEIGHT, 1, -1);
                    glMatrixMode(GL_MODELVIEW);

                    glViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                } catch (final LWJGLException e) {
                    e.printStackTrace();
                    System.exit(0);
                }
            }

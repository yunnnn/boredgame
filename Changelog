V0.11  11/10/15: Switched to Jpanels, have basic BG/Map/Location/Unit showing.
V0.12  11/10/15: Switched to nested Panels, allowing keyboard listener and highlighting to work.
V0.13  11/15/15: Added highlighting of locations and grid movement. Flipped the location rendering so locations in
proper visual location.
V0.14  11/16/15: Added dynamic grid size and fitted unit image size. Refactored Singletons.
V0.15  11/16/15: Added new panel to represent the map BG, added simple menu
V0.15b 11/16/15: Added Players, Turns, GameState. Moved UI logic to GamePanel, game Logic to GameState

Bugs:
0. Resizing the screen causes the GRID to disappear (behind the MAP)
1. LayeredPane & Layers apparently do nothing, it all depends on what is called first. How do we actually stack
things correctly?

In Progress:
0. Get UML diagrammer tool and map out the GameObject tree, the UIPanel tree, and the Cross interaction tree.

Todos:
0. SWING OBJECT MODEL: Figure out if the swing object model is actually best practice
1. UNITPANEL: Fix unitPanel so it actually represents a Unit. Currently the Unit image is Hardcoded into LocationPanel.
UnitPanels problem: Either it shows the image and isnt transparent, or it doens't show at all.
2. REDRAW: Figure out how to redraw units so they can move.
3. MENU: Update the menu with relevant information.
4. SELECTING LOCATIONS: when a location is selected, and RETURN is entered, it needs to show a different colored
border indicating that it is selected.
4.1. SELECTING LOCATIONS wrt CURRENT LOCATION CONTEXT: These are both represented by a pixel Border. However, you can't
have 2 borders, so there's no way to show both at the same time. Figure out how to show both at the same time.
5. POSSIBLE MOVEMENT UIs: If a Location is selected with a Unit inside, show the possible range of movement in the UI.
Assume the unit can move 2 squares. Highlight the range somehow. Again, this can't collide with 4.1 either.
6. RULES ENGINE that governs POSSIBLE MOVEMENT. Units should not be able to move to squares that already have units,
but they can move around them (so the PossMovement area can be a nonDiamond).







Old crap:


    //logging
    public void logLoad(final String imageName,
                        final int x,
                        final int y,
                        final Dimension size,
                        final Integer depth) {
        final StringBuilder sb = new StringBuilder();
        sb.append("Image: " + imageName + ", ");
        sb.append("At {" + x + "," + y + "}, ");
        sb.append("Width:" + size.getWidth() + " Height:" + size.getHeight() + " ");
        sb.append("Depth: " + depth + ". ");
        System.out.println(sb.toString());
    }

    //load an image into the layeredPane at {x,y}
    public void loadImage(final ImageIcon image,
                          final Integer depth,
                          final int x,
                          final int y) {
        final JLabel imageContainer = new JLabel(image);
        final Dimension size = imageContainer.getPreferredSize();
        imageContainer.setBounds(x, y, size.width, size.height);
        logLoad(image.getDescription(), x, y, size, depth);
        this.layeredPane.add(imageContainer, depth);
    }


public static void load() {

           //To render the image
           BufferedImage bufferedImage = new BufferedImage(800,
                   600, BufferedImage.TYPE_INT_RGB);

           //using "painter" we can draw in to "bufferedImage"
           Graphics2D painter = bufferedImage.createGraphics();

           //draw the "image" to the "bufferedImage"
           painter.drawImage(image, null, null);

        ByteBuffer imageBuffer = ByteBuffer.allocateDirect(4*source.getWidth()*source.getHeight());
        byte buffer[] = (byte[])source.getRaster().getDataElements(0,0,source.getWidth(),source.getHeight(),null);
        imageBuffer.clear();
        imageBuffer.put(buffer);
        imageBuffer.rewind();

        IntBuffer address = ByteBuffer.allocateDirect(4).order(ByteOrder.nativeOrder()).asIntBuffer();
        GL11.glGenTextures(address);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,address.get(0));

           // Setup the ST coordinate system
           GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
           GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
           glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
           glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

        GL11.glTexImage2D(GL11.GL_TEXTURE_2D,0,GL11.GL_RGBA,source.getWidth(),source.getHeight(),0,GL11.GL_RGB,GL11
                .GL_UNSIGNED_BYTE,imageBuffer);

       } catch (final FileNotFoundException e) {
           e.printStackTrace();
           System.out.println("FAILwidth=");
       } catch (IOException e) {
           System.out.println("wiFAILdth=");
           e.printStackTrace();

    }
}
    public static void load1() {
        InputStream in = null;
        try {

            in = new FileInputStream("blue.png");
            PNGDecoder decoder = new PNGDecoder(in);

            System.out.println("width =" + decoder.getWidth());
            System.out.println("height =" + decoder.getHeight());

            ByteBuffer buf = ByteBuffer.allocateDirect(4 * decoder.getWidth() * decoder.getHeight());
            decoder.decode(buf, decoder.getWidth() * 4, PNGDecoder.Format.RGB);
            buf.flip();


            int texId = GL11.glGenTextures();
            GL13.glActiveTexture(GL13.GL_TEXTURE0);
            GL11.glBindTexture(GL11.GL_TEXTURE_2D, texId);

            // Setup the ST coordinate system
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

            // Upload the texture data and generate mip maps (for scaling)
            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, decoder.getWidth(), decoder.getHeight(), 0,
                    GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, buf);





            in.close();
        } catch (final FileNotFoundException e) {
            e.printStackTrace();
            System.out.println("FAILwidth=");
        } catch (IOException e) {
            System.out.println("wiFAILdth=");
            e.printStackTrace();
        }
    }
    /**
     * Draw the sprite at the specified location
     *
     */
    public static void draw() {


        //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);


        // store the current model matrix
        glPushMatrix();


        // translate to the right location and prepare to draw
        glTranslatef(100, 200, 0);


        glEnable(GL_TEXTURE_2D);
        // draw a quad textured to match the sprite
        glBegin(GL_QUADS);
        {

            glTexCoord2f(0, 0);
            glVertex2f(0, 0);

            glTexCoord2f(0, 600);
            glVertex2f(0, 600);

            glTexCoord2f(600, 600);
            glVertex2f(600, 600);

            glTexCoord2f(600, 0);
            glVertex2f(600, 0);
        }
        glEnd();
        glDisable(GL_TEXTURE_2D);

        // restore the model view matrix to prevent contamination
        glPopMatrix();
    }



        private static void renderLoop(final LevelMap map) {
            TextureLoader.load();
            while (!Display.isCloseRequested()) {
                // Clear the screen and depth buffer
                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
                TextureLoader.draw();
               // map.render();
                Display.update();
            }
            Display.destroy();
        }


        private static void initUi() {
                try {
                    Display.setDisplayMode(new DisplayMode(SCREEN_WIDTH, SCREEN_HEIGHT));
                    Display.setTitle("Bored Game");
                    Display.setFullscreen(false);
                    Display.create();

                    glEnable(GL_TEXTURE_2D);
                    // not needed for 2d
                    glDisable(GL_DEPTH_TEST);

                    glMatrixMode(GL_PROJECTION);
                    glLoadIdentity();
                    glOrtho(0, SCREEN_WIDTH, 0, SCREEN_HEIGHT, 1, -1);
                    glMatrixMode(GL_MODELVIEW);

                    glViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                } catch (final LWJGLException e) {
                    e.printStackTrace();
                    System.exit(0);
                }
            }
